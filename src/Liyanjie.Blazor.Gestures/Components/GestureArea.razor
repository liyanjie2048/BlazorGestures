<CascadingValue Value="@(this)">
    <gesture-area style="display:block;-webkit-touch-callout:none!important;-webkit-user-select:none!important;-webkit-user-drag:none!important;touch-action:none!important;user-select:none!important"
        @attributes=@(InputAttributes)
        @ontouchstart=@(TouchStart) @ontouchstart:preventDefault=@(PreventDefault)
        @ontouchmove=@(TouchMove) @ontouchmove:preventDefault=@(PreventDefault)
        @ontouchend=@(TouchEnd) @ontouchend:preventDefault=@(PreventDefault)
        @onmousedown=@(MouseDown) @onmousedown:preventDefault=@(PreventDefault)
        @onmousemove=@(MouseMove) @onmousemove:preventDefault=@(PreventDefault)
        @onmouseup=@(MouseUp) @onmouseup:preventDefault=@(PreventDefault)>
        @ChildContent
    </gesture-area>
</CascadingValue>

@code {
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter(CaptureUnmatchedValues = true)] public Dictionary<string, object>? InputAttributes { get; set; }
    [Parameter] public bool Active { get; set; } = true;
    [Parameter] public bool PreventDefault { get; set; } = false;
    [Parameter] public bool AllowMouseSimulation { get; set; }

    public bool GestureStart { get; set; }
    public DateTime GestureStartTime { get; set; }
    public int GestureDuration => (int)(DateTime.Now - GestureStartTime).TotalMilliseconds;

    public TouchPoint[]? StartPoints { get; set; }
    public TouchPoint[]? CurrentPoints { get; set; }

    public EventHandler<TouchEventArgs>? GestureStarted { get; set; }
    public EventHandler<TouchEventArgs>? GestureMoved { get; set; }
    public EventHandler<TouchEventArgs>? GestureEnded { get; set; }

    void TouchStart(TouchEventArgs e)
    {
        if (!Active)
            return;

        GestureStart = true;
        GestureStartTime = DateTime.Now;
        StartPoints = e.Touches;
        CurrentPoints = e.Touches;
        GestureStarted?.Invoke(this, e);
    }
    void TouchMove(TouchEventArgs e)
    {
        if (!Active)
            return;

        CurrentPoints = e.Touches;
        GestureMoved?.Invoke(this, e);
    }
    void TouchEnd(TouchEventArgs e)
    {
        if (!Active)
            return;

        GestureEnded?.Invoke(this, e);
    }

    void MouseDown(MouseEventArgs e)
    {
        if (Active && AllowMouseSimulation)
            TouchStart(new()
                {
                    Type = "mousedown",
                    Touches = GetTouchPoint(e),
                    TargetTouches = GetTouchPoint(e),
                    ChangedTouches = GetTouchPoint(e),
                });
    }
    void MouseMove(MouseEventArgs e)
    {
        if (Active && AllowMouseSimulation)
            TouchMove(new()
                {
                    Type = "mousemove",
                    Touches = GetTouchPoint(e),
                    TargetTouches = GetTouchPoint(e),
                    ChangedTouches = GetTouchPoint(e),
                });
    }
    void MouseUp(MouseEventArgs e)
    {
        if (Active && AllowMouseSimulation)
            TouchEnd(new()
                {
                    Type = "mouseup",
                    Touches = Array.Empty<TouchPoint>(),
                    TargetTouches = Array.Empty<TouchPoint>(),
                    ChangedTouches = GetTouchPoint(e),
                });
    }

    TouchPoint[] GetTouchPoint(MouseEventArgs e)
    {
#if NET6_0_OR_GREATER
    return new TouchPoint[]{ new() { ClientX = e.ClientX, ClientY = e.ClientY, PageX = e.PageX, PageY = e.PageY, ScreenX = e.ScreenX, ScreenY = e.ScreenY }};
#else
        return new TouchPoint[] { new() { ClientX = e.ClientX, ClientY = e.ClientY, ScreenX = e.ScreenX, ScreenY = e.ScreenY } };
#endif
    }
}
